Let \(G\) be cicular group where the discrete logrithem problem is assumed to be hard to solve. For simplicity we assume \(G\) is cicular over \(Fr\) from now on.

Let \(g, \vec{g}=(g_1, g_2, \cdots), h, \vec{h}=(h_1, h_2, \cdots)\) be base points of \(G\) whose logrithem relationship is unclear.


* Encryption and Decryption of Balance

Let \(y_1 = g^{s_1}\) (resp. \(y_2 = g^{s_2}\)) be public key of secret key \(s_1\) (resp. \(s_2\)). Assume the balance of every account is in the interval \([0, 2^n)\), where \(n\) is a small integer like \(32\). The ciphertexts obtained from encrypting balance \(b_1\) (resp. \(b_2\)) with public key \(y_1\) (resp. \(y_2\)) is \(c_1 = (g^{b_1} * {y_1}^r, g^r_1)\) (resp. \(c_2 = (g^{b_2} * {y_2}^r, g^r_2)\)), where \(r_1\) and \(r_2\) are random scalars. This is also called ElGamal Commitment.

Using the ususal ElGamal decryption, we can obtain \(g^{b_1}\) (resp. \(g^{b_2}\)) from ciphertext \(c_1\) (resp. \(c_2\)), i.e. we calculate \(\frac{g^{b_1} * {y_1}^r}{g^{r_1}^P{s_1}\) which equals \(g^{b_1}\) by definition of the public key \(y_1 = g^{s_1}\). We then obtain \(b_1\) (resp. \(b_2\)) with brute force. This is feasible as \(b_1, b_2\) are small enough.

* Confidential Transfer

For the same public key \(y\), we define the addtion/subtraction of two ciphertexts \(c_1 = (g^{b_1} * {y}^{r_1}, g^{r_1}), c_2 = (g^{b_2} * {y_2}^{r_2}, g^r_2)\) as the multiplication/division in the group \(G^2\), for example, \(c_1 + c_2 = (g^{b_1+b_2} * {y}^{r_1+r_2}, g^{r_1+r_2})\). It is easy to verify the decrytion of the resulting ciphertext is indeed the addtion/subtraction of coresponding balance.

That is to say, the mapping from balance interval to ciphertext homomorphic, we can do the math on ciphertexts which corresponds exactly to the math on balances.

We want to make a transaction from account X to Y, we assume \(Y\) initially has balance \(b\), he/she wants to transfer \(b^\star\) to \(\bar{Y}\). In the good old bitcoin world. We need only check, it is indeed \(Y\) made the transaction, and \(Y\) didn't transfer more than what he/she has, i.e. \(b\).

In the brave new world of cryptopia, we have no way to know what \(b\) and \(b^\star\) are, as they are both encrypted.

* Proof of knowledge of discrete logarithm

Now let's recapulate what we want to do.

Suppose \(Y\), whose public key is \(y\), secret key is \(sk\), wants to transfer \(b^\star\) to \(\bar{Y}\), whose public key is \(\bar{y}\), in the end, X has only \(b^\prime\) left in his/her wallet. Our goal is then to prove the following statements.

1. The ciphertext \((C, D)\) of \(b^\star\) under public key \(y\) and random number \(r\) is \((b^\star * g + r * y, r * g)\).
2. The ciphertext \((\bar{C}, D)\) of \(b^\star\) under public key \(\bar{y}\) and random number \(r\) is \((b^\star * g + r * \bar{y}, r * g)\).
3. \(C_{n}, D_{n}\), the amount of money of \(Y\) left after the transaction is the ElGamal encryption of \(b^\prime\) under public key \(Y\), i.e. \(C_n = b^\star * g + sk * D_n\) and \(sk * g = y\).
4. Both \(b^\star\) and \(b^\prime\) are within the range \([0, 2^n)\).

We can make use of Schnorr's protocol to prove the first three statements.

In Schnorr's protocol, the prover wants to prove that the pair \((x, h)\) satifies relationship \(h = x * g\) where \(g\) is a know element of group \(G\). Schnorr's protocol. First the prover randomly choose a scalar \(r\) and send \(u = r * g\) to the verifier. The verifier send the randomly choosed chanlledge \(c\) to the  prover. The honest prover send \(v = (c * x + r) * g\) to the verifier. The verifier outputs \( v == c*h + u \).

With little changes, we can extend Schnorr's protocol to prove statements like \(C = b^\star * g + r * y\). Now We need only a proof which proves both \(b^\star\) and \(b^\prime\) are within the range \([0, 2^n)\), without ever revealing the actual value of \(a\). This is how bulletproofs come to the stage.

* Pederson Commitment

We now provide another way to hide balance which also allow us prove to statement about the hidden balance. Instead of encrypting balance with ElGamal encryption, we commit it with Pederson commitment. Given a value \(v\) in the message space, we can commit this value and obtain a output \(c\) in the commitment space. \(c\) is called the commitment of \(v\).

There are two properties concerning the security of a commitment scheme, binding and hiding. Informally, a commitment is said to be binding if we can not find two values whose commitment are equal, a commitment is said to be hiding is we can not discern two values from each other. If in addition to this two properties, the commitment scheme is homomorphic, then we translate statements from message space to commitment space. This is quite useful for us to prove properties of hidden values.

One of the hiding, binding and homomorphic commitment scheme is Pederson commitment. The Pederson commitment of \((b, r) \in (Z, Z)\) is defined to be the function \(PC: (b, r) \mapsto b*g + r*h\) where \(g\) and \(h\) are fixed base points, \(r\) is called the blinding factor of \(b\). Note that in Pederson Commitment \(h\) is fixed. We can easily verify Pedenson commitment is a homomorphic commitment scheme, i.e. \(\forall b_1, r_1, b_2, r_2\), we have \(PC(b_1+b_2, r_1+r_2) PC(b_1, r_1), PC(b_2, r_2)\).

We generalize Pederson Commitment to vectors. Let \((a_L, a_R) \in (Z^n, Z^n)\), we define the Pederson commitment to be the function \(PC: (a_L, a_R, r_L, r_R) \mapsto \sum a_L_i * g_i + \sum a_R_i * h_i + rh\) where \(h\), \(g_i\) and \(h_i\) are fixed base points, \(r\) is called the blinding factor of \((a_L, a_R)\).

* Zen of Range Checking

Instead of proving \(a\) is within the range \([0, 2^n)\) directly. We prove the following equivalent equation. To be more precise, we prove them the homomorphism image of those terms are equal as many of the terms need to be hidden, we will pin down how to do it shortly.

#+NAME: eqn:1
\[a - \sum_{i=1}^{n} a_L_i \times 2^{i-1} = 0\]
#+NAME: eqn:2
\[a_L_i - 1 - a_R_i = 0, \forall i \in [1, n]\]
#+NAME: eqn:3
\[a_R_i * a_L_i = 0, \forall i \in [1, n]\]

Combining the second and the third equation, we have \((a_L_i - 1) * a_L_i = 0\), i.e. \(a_L_i = 1\) or \(a_L_i = 0\). Together with the first equation, we can see that \(a\) is indeed within the range \([0, 2^n)\).

To verify the second equation, the verifier makes a chanlledge, a random scalar \(y\), to the prove. The prover proves that,
#+NAME: eqn:4
\[ \sum_{i=1}^{i=n} (a_L_i - 1 - a_R_i)^y^i = 0\]

The left side of the above equation is a polynomial of degree at most \(n\), so it has at most \(n\) roots. \(y\) is highly unlikely to be a root of the polynomial unless all coeffiecents are zero. Thus we only need to verify a single equation,

#+NAME: eqn:5
\[ \sum_{i=1}^{i=n} (a_L_i - 1 - a_R_i)^y^i = 0\]

Using the same argument, verifying \( \sum_{i=1}^{i=n} (a_L_i * a_R_i)^y^i = 0\) is enough for the third equation.

Denote \(\vec{y}_n = (y, y^2, \cdots, y^{n})\), \(a_L = (a_L_1, a_L_2, \cdots, a_L_n)\), \(a_R = (a_R_1, a_R_2, \cdots, a_R_n)\). Let \(X\), \(Y\) be two vector in \(Fr^n\), we denote the Euclid inner product \(X\cdot Y\), the Hermitian product \(X \circ Y\).

Rewrite equation [[eqn:4]] as \((a_L - \vec{1}_n - a_R) \cdot \vec{y}_n\), rewrite equation [[eqn:5]] as \((a_L) \cdot (a_R \circ y) = 0\), rewrite [[eqn:1]] as \(a - a_L \cdot \vec{y}_n = 0\). Using the trick as above, we combine this equations to a single equation

#+NAME: eqn:6
\[(a_L - \vec{1}_n - a_R) \cdot \vec{y}_n + a_L\cdot (a_R \circ y) * z + (a - a_L \cdot \vec{y}_n)* z^2 = 0\]

This equation is equivalent to
#+NAME: eqn:7
\[(a_L - z\vec{1}_n) \cdot (a_R\circ \vec{y}_n + z\vec{1}_n\circ \vec{y}_n + z^2\circ \vec{2}_n) = z^2 v + \delta(y, z)\]

where \(\delta(y, z) = (z - z^2)(\vec{1}_n \cdot \vec{y}_n) - z^3 \vec{1}_n\vec{2}_n\) is a term which can be easily calculated as it involves only \(y\) and \(z\).

In order to make the range proof zero knowledge, we will add additional term \(s_Lx\) (resp. \(s_Rx\)) to \(a_L\) (resp. \(a_R\)), where \(s_L, s_R \in Fr^n\) are random vectors, \(x\) is unknown variable in \(Fr\). Thus the left side of equation [[eqn:7]] is now a polynomial of degree 2. We now have a equation of the following form
#+NAME: eqn:8
\[l(x) \cdot r(x) = t_0 + t_1x + t_2x^2 = t(x)\]

where
#+NAME: eqn:9
\[l(x) = a_L + s_Lx - z\vec{1}_n\]
#+NAME: eqn:10
\[r(x) = (a_R + s_Rx) \circ \vec{y}_n + z\vec{1}_n\circ \vec{y}_n + z^2\circ \vec{2}_n\]
#+NAME: eqn:11
\[t(x) = t_0 + t_1 x + t_2 x^2 = z^2 v + \delta(y, z) + t_1 x + t_2 x^2\]

* Range Proof

We now have every ingredients for to check a range proof.

We now view \(x\) as a random scalar. Let \(V\) be the Pederson Commitment of \(v\), \(T_1\) be the Pederson Commitment of \(t_1\), \(T_2\) be the Pederson Commitment of \(t_2\), \(A = PC(a_L, a_R, \tilde{a})\) where \(\tilde{a}\) is a random scalar known only to the prover, \(P = PC(l(x), r(x), \tilde{p})\) where \(\tilde{p}\) is a random scalar known only to the prover, \(T = PC(t(x), \tilde{t}(x))\) be the Pederson commitment of \(t(x)\).

The range proof consists of \((V, A, S, T_1, T_2, \tilde{t}(x), t(x), \tilde{p})\) and a proof which proves that \(t(x)\) is indeed the inner product of \(l(x)\) and \(r(x)\), i.e. [[eqn:8]] holds.

To verify [[eqn:9]] and [[eqn:10]], we note the Pederson commitment of \((a_L + s_Lx - z\vec{1}_n, (a_R + s_Rx) \circ \vec{y}_n + z\vec{1}_n\circ \vec{y}_n + z^2\circ \vec{2}_n)\) can be calculated from \(A, S\). Given the blinding factor of the Pedenson commitment of \(l(x), r(x)\), we can calculate the commitment of \((l(x), r(x))\) in the inner product proof. Thus we can only verify the given inner product proof with the commitment calculated from above.

To verify [[eqn:11]], we compare the commitment of \(t(x)\) with the commitment of \(z^2 v + \delta(y, z) + t_1 x + t_2 x^2\). The first term can be calculated directly with \(\tilde{t}(x), t(x)\), and the second term can be calculated with \(V, T_1, T_2\).

* Aggregated Range Proof

In our use case, we want to aggregate two range proofs. To aggreate \(k\) range proof, we have the following equations

\[(a_L - \vec{1}_n - a_R) \cdot \vec{y}_n + a_L\cdot (a_R \circ y) * z + (a - a_L \cdot \vec{y}_n)* z^2 = 0\]

#+NAME: eqn:12
\[a_k - \sum_{i=1}^{n} a_k_L_i \times 2^{i-1} = 0\]
#+NAME: eqn:13
\[a_k_L_i - 1 - a_k_R_i = 0, \forall i \in [1, n]\]
#+NAME: eqn:14
\[a_k_R_i * a_k_L_i = 0, \forall i \in [1, n]\]

Not when we concatenate all the binary represention of \(a_k_L_i\) (resp. \(a_k_R_i\)) into \(a_L_i\) (resp. \(a_R_i\)), we can condense [[eqn:13]] (resp. [[eqn:14]]) into the [[eqn:2]] (resp. [[eqn:3]]). We use the same trick as before to condense those equation into
\[(a_L - \vec{1}_n - a_R) \cdot \vec{y}_n + a_L\cdot (a_R \circ y) * z + \sum(a_i - a_L_i \cdot \vec{y}_n)* z^{2+i} = 0\]

Accordingly, we need to adjust terms in [[eqn:9]], [[eqn:10]] and [[eqn:11]]. After that, we can verify the proof in the same way.
